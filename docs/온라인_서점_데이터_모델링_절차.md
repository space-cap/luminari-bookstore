# 실무 관점에서의 데이터 모델링 절차 (온라인 서점 예시)

프로젝트를 시작할 때, 특히 데이터베이스 구조를 설계하는 '데이터 모델링'은 집을 짓기 전 설계도를 그리는 것과 같이 매우 중요합니다. 아래 절차는 실무에서 일반적으로 따르는 데이터 모델링 과정입니다.

## 1단계: 요구사항 분석 (무엇을 만들어야 하는가?)

가장 먼저, 이 프로젝트가 어떤 기능들을 가져야 하는지 명확히 정의해야 합니다.

*   **핵심 기능 나열**:
    *   사용자는 회원가입 및 로그인을 할 수 있다.
    *   사용자는 책을 검색할 수 있다.
    *   사용자는 책 상세 정보를 볼 수 있다.
    *   사용자는 책에 대한 리뷰를 작성하고 볼 수 있다.
    *   사용자는 책을 장바구니에 담을 수 있다.
    *   사용자는 장바구니에 담긴 상품들을 주문할 수 있다.
    *   사용자는 자신의 주문 내역을 볼 수 있다.

*   **핵심 '명사' 추출**: 위 기능 목록에서 중요한 대상(명사)들을 뽑아냅니다. 이것이 곧 데이터 모델의 기본 단위인 '엔티티(Entity)'가 됩니다.
    *   **회원 (Member)**
    *   **책 (Book)**
    *   **리뷰 (Review)**
    *   **장바구니 (Cart)**
    *   **주문 (Order)**
    *   (추가적으로) **저자 (Author)**, **출판사 (Publisher)**, **카테고리 (Category)** 등

## 2단계: 개념적 데이터 모델링 (핵심 요소와 관계 정의)

요구사항 분석에서 추출한 엔티티들을 바탕으로, 각 엔티티가 어떤 정보를 가져야 하고, 서로 어떤 관계를 맺고 있는지 큰 그림을 그립니다.

*   **엔티티(Entity)와 속성(Attribute) 정의**:
    *   **회원**: 아이디, 비밀번호, 이름, 이메일, 주소
    *   **책**: 제목, 저자, ISBN, 가격, 출판사, 출간일
    *   **주문**: 주문번호, 주문날짜, 총액, 배송지 주소

*   **엔티티 간의 관계(Relationship) 정의**:
    *   한 명의 **회원**은 여러 개의 **주문**을 할 수 있다. (1:N, 일대다 관계)
    *   하나의 **주문**에는 여러 종류의 **책**이 포함될 수 있다. (N:M, 다대다 관계)
    *   하나의 **책**에는 여러 개의 **리뷰**가 달릴 수 있다. (1:N, 일대다 관계)
    *   한 명의 **회원**은 여러 개의 **리뷰**를 작성할 수 있다. (1:N, 일대다 관계)

이 단계에서는 종이에 다이어그램을 그리거나, 간단한 텍스트로 관계를 정리하는 방식으로 진행합니다.

## 3단계: 논리적 데이터 모델링 (데이터베이스 구조 설계)

개념적 모델링에서 정의한 내용을 실제 데이터베이스 테이블 구조로 변환하는 단계입니다.

*   **테이블(Table) 정의**: 각 엔티티를 테이블로 변환합니다.
*   **기본 키(Primary Key, PK)**: 각 테이블에서 데이터를 고유하게 식별할 수 있는 컬럼을 지정합니다. (예: `member_id`, `book_id`)
*   **외래 키(Foreign Key, FK)**: 테이블 간의 관계를 연결하기 위한 컬럼을 추가합니다.
    *   `Review` 테이블에는 어떤 회원이 썼는지(`member_id`), 어떤 책에 대한 리뷰인지(`book_id`)를 나타내는 FK가 필요합니다.
*   **다대다(N:M) 관계 처리**: '주문'과 '책'처럼 다대다 관계는 직접 표현할 수 없습니다. 이 관계를 해소하기 위해 중간에 '연결 테이블'(Junction Table)을 만듭니다.
    *   `Order_Book`이라는 연결 테이블을 만들고, `order_id`와 `book_id`를 각각 FK로 가집니다. 이 테이블에는 주문된 책의 수량(`quantity`)과 같은 추가 정보도 저장할 수 있습니다.

**예시)**
*   `MEMBER` (member_id: PK, username, password, ...)
*   `BOOK` (book_id: PK, title, author, price, ...)
*   `ORDERS` (order_id: PK, order_date, member_id: FK, ...)
*   `ORDER_BOOK` (order_book_id: PK, order_id: FK, book_id: FK, quantity, ...)

## 4단계: 물리적 데이터 모델링 (실제 데이터베이스에 적용)

논리적 모델을 실제 사용할 데이터베이스(예: MySQL, PostgreSQL)의 특성에 맞게 구체화하는 마지막 단계입니다.

*   **데이터 타입 정의**: 각 컬럼에 맞는 데이터 타입을 지정합니다. (예: `title`은 `VARCHAR(255)`, `price`는 `DECIMAL(10, 2)`, `order_date`는 `DATETIME`)
*   **제약 조건(Constraints) 설정**: 데이터의 무결성을 지키기 위한 규칙을 설정합니다. (예: `NOT NULL`, `UNIQUE`, `DEFAULT` 값)
*   **인덱스(Index) 설계**: 데이터 조회 성능을 높이기 위해 어떤 컬럼에 인덱스를 생성할지 결정합니다. (예: 책 제목으로 검색하는 경우가 많으므로 `BOOK` 테이블의 `title` 컬럼에 인덱스를 생성)

---

이러한 체계적인 단계를 거치면, 요구사항이 잘 반영되고 확장성과 유지보수성이 높은 데이터베이스 구조를 설계할 수 있습니다. 처음에는 어렵게 느껴질 수 있지만, 작은 기능부터 시작하여 점차 확장해나가는 방식으로 연습하는 것이 좋습니다.
