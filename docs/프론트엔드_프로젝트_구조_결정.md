# 프론트엔드 프로젝트 구조 결정: 모노레포 vs 멀티레포

## 목차
1. [현황 분석](#1-현황-분석)
2. [모노레포와 멀티레포 비교](#2-모노레포와-멀티레포-비교)
3. [결정: 모노레포 선택](#3-결정-모노레포-선택)
4. [제안하는 프로젝트 구조](#4-제안하는-프로젝트-구조)
5. [개발 환경 설정](#5-개발-환경-설정)
6. [배포 전략](#6-배포-전략)
7. [확장 시나리오](#7-확장-시나리오)
8. [실행 계획](#8-실행-계획)

---

## 1. 현황 분석

### 1.1 현재 프로젝트 상태

**기술 스택**:
- **Backend**: Spring Boot (Java 17)
- **Database**: MySQL 8.0
- **Frontend**: React + Vite (예정)

**프로젝트 특성**:
- 단일 도메인 애플리케이션 (온라인 서점)
- MVP → 상용 서비스로 확장 예정
- 1인 또는 소규모 팀
- 밀접하게 연결된 프론트엔드/백엔드

**현재 저장소 구조**:
```
luminari-bookstore/
├── .factory/
├── .git/
├── .gitattributes
├── .gitignore
├── .mvn/
├── docs/                    # 문서 (요구사항, 데이터 모델링)
├── database/                # SQL 스크립트
├── src/                     # Spring Boot 소스
├── target/
├── mvnw
├── mvnw.cmd
├── pom.xml
└── GEMINI.md
```

---

## 2. 모노레포와 멀티레포 비교

### 2.1 모노레포 (Monorepo)

**정의**: 여러 프로젝트를 하나의 Git 저장소에서 관리

**장점**:
- ✅ **단일 진실 공급원**: 모든 코드가 한 곳에
- ✅ **원자적 커밋**: 프론트/백엔드 동시 변경 가능
- ✅ **공유 용이**: 문서, 타입 정의, 유틸리티 공유
- ✅ **간단한 설정**: 한 번의 `git clone`으로 전체 프로젝트
- ✅ **일관된 버전 관리**: 프론트/백엔드 버전 동기화
- ✅ **통합 CI/CD**: 하나의 파이프라인으로 관리
- ✅ **리팩토링 용이**: 전체 영향 범위 즉시 파악

**단점**:
- ❌ **저장소 크기**: 시간이 지나면 커질 수 있음
- ❌ **빌드 시간**: 전체 빌드 시 시간 소요 (해결 가능)
- ❌ **접근 권한 제어**: 세밀한 권한 관리 어려움
- ❌ **학습 곡선**: 초기에 구조 이해 필요

**적합한 경우**:
- 단일 애플리케이션
- 밀접하게 연결된 프론트/백엔드
- 소규모 팀 (통신 오버헤드 최소)
- 빠른 개발 속도 필요

**예시**:
- Google (Bazel로 관리)
- Facebook (Mercurial)
- Twitter (Pants 빌드 시스템)

---

### 2.2 멀티레포 (Multirepo / Polyrepo)

**정의**: 각 프로젝트를 별도의 Git 저장소로 관리

**장점**:
- ✅ **독립성**: 각 프로젝트 완전히 분리
- ✅ **접근 권한**: 저장소별 세밀한 권한 관리
- ✅ **작은 저장소**: 각 저장소 크기 작음
- ✅ **독립 배포**: 각자의 배포 주기
- ✅ **기술 스택 자유도**: 각 저장소별 다른 도구 사용 가능

**단점**:
- ❌ **동기화 어려움**: API 변경 시 여러 저장소 수정 필요
- ❌ **중복 코드**: 공통 코드 공유 어려움
- ❌ **복잡한 설정**: 여러 저장소 클론 및 관리
- ❌ **버전 불일치**: 프론트/백엔드 버전 관리 복잡
- ❌ **이슈 추적 분산**: 여러 저장소에 이슈 분산

**적합한 경우**:
- 마이크로서비스 아키텍처
- 독립적인 팀 운영
- 다른 릴리즈 주기
- 재사용 가능한 라이브러리/패키지

**예시**:
- Netflix (수백 개의 마이크로서비스)
- Amazon (서비스별 독립 저장소)

---

### 2.3 비교표

| 항목 | 모노레포 | 멀티레포 |
|:-----|:---------|:---------|
| **저장소 수** | 1개 | 여러 개 |
| **코드 공유** | ✅ 매우 쉬움 | ❌ 어려움 (NPM 패키지 등 필요) |
| **API 동기화** | ✅ 원자적 커밋 가능 | ❌ 수동 동기화 필요 |
| **버전 관리** | ✅ 단일 버전 | ❌ 각 저장소별 버전 |
| **CI/CD** | ✅ 통합 파이프라인 | ❌ 저장소별 설정 |
| **이슈 관리** | ✅ 한 곳에서 추적 | ❌ 분산 추적 |
| **접근 권한** | ❌ 세밀한 제어 어려움 | ✅ 저장소별 제어 |
| **초기 설정** | ✅ 한 번의 클론 | ❌ 여러 번 클론 |
| **빌드 시간** | ❌ 전체 빌드 시 오래 걸림 | ✅ 각 프로젝트별 빠름 |
| **팀 규모** | ✅ 소규모 팀에 유리 | ✅ 대규모 팀에 유리 |
| **프로젝트 유형** | ✅ 단일 애플리케이션 | ✅ 마이크로서비스 |

---

## 3. 결정: 모노레포 선택

### 3.1 선택 이유

**Luminari Bookstore 프로젝트에 모노레포가 적합한 이유**:

#### ✅ 1. 단일 애플리케이션
- 온라인 서점이라는 하나의 도메인
- 프론트엔드와 백엔드가 밀접하게 연결
- API 변경 시 프론트/백엔드 동시 수정 필요

#### ✅ 2. 소규모 팀
- 1인 또는 소규모 팀 운영
- 통신 오버헤드 최소화
- 빠른 의사결정 및 개발 속도

#### ✅ 3. MVP 단계
- 빠른 프로토타이핑 필요
- 잦은 요구사항 변경
- 전체 프로젝트 파악 용이

#### ✅ 4. 공유 자원
- 데이터 모델링 문서 공유
- API 명세 공유
- 타입 정의 공유 가능 (TypeScript ↔ Java)

#### ✅ 5. 일관된 버전 관리
- 프론트/백엔드 버전 동기화
- 단일 릴리즈 노트
- 명확한 배포 이력

---

### 3.2 우려사항 해결

#### 우려 1: 저장소가 너무 커지지 않을까?
**해결**:
- Git LFS로 대용량 파일 관리
- `.gitignore`로 빌드 결과물 제외
- 실제로는 소스 코드만 있어 크기 문제 없음

#### 우려 2: 빌드 시간이 오래 걸리지 않을까?
**해결**:
- CI/CD에서 변경된 부분만 빌드 (GitHub Actions `paths` 필터)
- 프론트/백엔드 병렬 빌드
- 캐싱 활용

```yaml
# 예시: GitHub Actions
on:
  push:
    paths:
      - 'frontend/**'  # 프론트만 변경 시 프론트만 빌드
```

#### 우려 3: 나중에 분리해야 하면?
**해결**:
- Git의 `subtree`, `filter-branch`로 쉽게 분리 가능
- 하지만 대부분의 경우 불필요
- 정말 필요할 때 분리해도 늦지 않음

---

## 4. 제안하는 프로젝트 구조

### 4.1 최종 디렉토리 구조

```
luminari-bookstore/                      ← 모노레포 루트
├── .github/
│   └── workflows/
│       ├── backend-ci.yml               ← 백엔드 CI/CD
│       ├── frontend-ci.yml              ← 프론트엔드 CI/CD
│       └── deploy.yml                   ← 통합 배포
│
├── backend/                             ← Spring Boot 프로젝트
│   ├── .mvn/
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/
│   │   │   │   └── com/luminari/bookstore/
│   │   │   │       ├── domain/          ← 도메인 엔티티
│   │   │   │       ├── repository/      ← JPA Repository
│   │   │   │       ├── service/         ← 비즈니스 로직
│   │   │   │       ├── controller/      ← REST API
│   │   │   │       ├── dto/             ← 데이터 전송 객체
│   │   │   │       ├── security/        ← 인증/인가
│   │   │   │       └── config/          ← 설정
│   │   │   └── resources/
│   │   │       ├── application.yml
│   │   │       └── application-dev.yml
│   │   └── test/
│   ├── target/                          ← (gitignore)
│   ├── mvnw
│   ├── mvnw.cmd
│   ├── pom.xml
│   ├── Dockerfile
│   └── README.md
│
├── frontend/                            ← React + Vite 프로젝트
│   ├── public/
│   │   └── images/
│   ├── src/
│   │   ├── assets/                      ← 이미지, 폰트 등
│   │   ├── components/                  ← 재사용 컴포넌트
│   │   │   ├── common/                  ← 공통 컴포넌트
│   │   │   ├── layout/                  ← 레이아웃
│   │   │   ├── book/                    ← 도서 관련
│   │   │   ├── member/                  ← 회원 관련
│   │   │   ├── order/                   ← 주문 관련
│   │   │   └── community/               ← 커뮤니티 관련
│   │   ├── pages/                       ← 페이지 컴포넌트
│   │   │   ├── Home.tsx
│   │   │   ├── BookDetail.tsx
│   │   │   ├── Cart.tsx
│   │   │   ├── Order.tsx
│   │   │   ├── MyPage.tsx
│   │   │   └── Admin/
│   │   ├── hooks/                       ← Custom Hooks
│   │   ├── services/                    ← API 클라이언트
│   │   │   ├── api.ts                   ← Axios 설정
│   │   │   ├── bookService.ts
│   │   │   ├── memberService.ts
│   │   │   ├── orderService.ts
│   │   │   └── reviewService.ts
│   │   ├── stores/                      ← 상태 관리 (Zustand/Redux)
│   │   ├── types/                       ← TypeScript 타입 정의
│   │   │   ├── book.ts
│   │   │   ├── member.ts
│   │   │   ├── order.ts
│   │   │   └── api.ts
│   │   ├── utils/                       ← 유틸리티 함수
│   │   ├── styles/                      ← 글로벌 스타일
│   │   ├── App.tsx
│   │   ├── main.tsx
│   │   └── router.tsx
│   ├── node_modules/                    ← (gitignore)
│   ├── dist/                            ← (gitignore)
│   ├── index.html
│   ├── package.json
│   ├── package-lock.json
│   ├── tsconfig.json
│   ├── vite.config.ts
│   ├── Dockerfile
│   └── README.md
│
├── database/                            ← 데이터베이스 스크립트
│   ├── scripts/
│   │   ├── 01_create_database.sql
│   │   ├── 02_create_tables.sql
│   │   ├── 03_create_triggers.sql
│   │   ├── 04_create_procedures.sql
│   │   ├── 05_insert_initial_data.sql
│   │   └── 99_rollback.sql
│   ├── deploy.bat
│   └── README.md
│
├── docs/                                ← 프로젝트 문서
│   ├── api/                             ← API 명세
│   │   ├── openapi.yaml                 ← OpenAPI 3.0 명세
│   │   └── README.md
│   ├── design/                          ← 디자인 문서
│   │   ├── UI_UX_가이드.md
│   │   └── 컴포넌트_명세.md
│   ├── database/                        ← DB 문서 (기존)
│   │   ├── 1단계_요구사항_분석_상세.md
│   │   ├── 2단계_개념적_데이터_모델링.md
│   │   ├── 3단계_논리적_데이터_모델링.md
│   │   └── 4단계_물리적_데이터_모델링.md
│   ├── deployment/                      ← 배포 가이드
│   │   ├── 로컬_개발_환경_설정.md
│   │   ├── Docker_배포_가이드.md
│   │   └── 프로덕션_배포_가이드.md
│   └── 프론트엔드_프로젝트_구조_결정.md  ← 이 문서
│
├── shared/                              ← 공유 리소스 (선택)
│   ├── types/                           ← 공유 타입 정의
│   └── utils/                           ← 공유 유틸리티
│
├── .gitignore
├── .gitattributes
├── docker-compose.yml                   ← 로컬 개발 환경
├── docker-compose.prod.yml              ← 프로덕션 환경
├── README.md                            ← 프로젝트 메인 README
└── GEMINI.md
```

---

### 4.2 각 디렉토리 역할

#### backend/
- Spring Boot 애플리케이션
- REST API 제공
- 비즈니스 로직 처리
- 데이터베이스 연동

#### frontend/
- React + Vite 애플리케이션
- 사용자 인터페이스
- API 클라이언트
- 상태 관리

#### database/
- SQL 스크립트
- 초기 데이터
- 마이그레이션 스크립트

#### docs/
- 모든 프로젝트 문서
- API 명세 (OpenAPI)
- 디자인 가이드
- 배포 가이드

#### shared/ (선택)
- 프론트/백엔드 공유 코드
- TypeScript 타입 정의
- 공통 유틸리티

---

## 5. 개발 환경 설정

### 5.1 프론트엔드 프로젝트 생성

```bash
# 프로젝트 루트에서
cd luminari-bookstore
npm create vite@latest frontend -- --template react-ts

cd frontend
npm install

# 추가 패키지 설치
npm install axios react-router-dom zustand
npm install -D @types/react-router-dom
```

---

### 5.2 Vite 프록시 설정

백엔드 API 프록시 설정으로 CORS 문제 해결:

```typescript
// frontend/vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  
  // 개발 서버 설정
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '')
      }
    }
  },
  
  // 경로 별칭 설정
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@pages': path.resolve(__dirname, './src/pages'),
      '@services': path.resolve(__dirname, './src/services'),
      '@types': path.resolve(__dirname, './src/types'),
      '@hooks': path.resolve(__dirname, './src/hooks'),
      '@utils': path.resolve(__dirname, './src/utils')
    }
  },
  
  // 빌드 설정
  build: {
    outDir: 'dist',
    sourcemap: true
  }
})
```

---

### 5.3 TypeScript 설정

```json
// frontend/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path mapping */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@components/*": ["./src/components/*"],
      "@pages/*": ["./src/pages/*"],
      "@services/*": ["./src/services/*"],
      "@types/*": ["./src/types/*"],
      "@hooks/*": ["./src/hooks/*"],
      "@utils/*": ["./src/utils/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

---

### 5.4 Docker Compose로 통합 개발 환경

**참고**: Docker Compose 설정 예시는 실제 구현 시 `.env` 파일로 환경변수를 관리하세요.

프로젝트 루트에 `docker-compose.yml` 파일을 생성하여 MySQL, 백엔드, 프론트엔드를 통합 실행할 수 있습니다.

**주요 구성**:
- MySQL 8.0 (포트 3306)
- Spring Boot 백엔드 (포트 8080)
- React 프론트엔드 (포트 3000)

**사용 방법**:
```bash
# 전체 환경 실행
docker-compose up -d

# 로그 확인
docker-compose logs -f

# 특정 서비스만 재시작
docker-compose restart backend

# 전체 종료
docker-compose down
```

---

### 5.5 백엔드 Dockerfile

```dockerfile
# backend/Dockerfile
FROM eclipse-temurin:17-jdk-alpine AS build

WORKDIR /app

# Maven Wrapper 복사
COPY mvnw .
COPY .mvn .mvn

# pom.xml 복사 및 의존성 다운로드
COPY pom.xml .
RUN ./mvnw dependency:go-offline -B

# 소스 코드 복사 및 빌드
COPY src src
RUN ./mvnw package -DskipTests

# 실행 이미지
FROM eclipse-temurin:17-jre-alpine

WORKDIR /app

# 빌드 결과물 복사
COPY --from=build /app/target/*.jar app.jar

# 포트 노출
EXPOSE 8080

# 실행
ENTRYPOINT ["java", "-jar", "app.jar"]
```

---

### 5.6 프론트엔드 Dockerfile

```dockerfile
# frontend/Dockerfile
FROM node:18-alpine AS build

WORKDIR /app

# package.json 복사 및 의존성 설치
COPY package*.json .
RUN npm ci

# 소스 코드 복사 및 빌드
COPY . .
RUN npm run build

# 프로덕션 이미지 (Nginx)
FROM nginx:alpine

# Nginx 설정
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

---

### 5.7 Nginx 설정 (프로덕션)

```nginx
# frontend/nginx.conf
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # React Router 처리 (SPA)
    location / {
        try_files $uri $uri/ /index.html;
    }

    # API 프록시 (선택)
    location /api {
        proxy_pass http://backend:8080;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # Gzip 압축
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript 
               application/x-javascript application/xml+rss 
               application/javascript application/json;
}
```

---

## 6. 배포 전략

### 6.1 GitHub Actions CI/CD

#### 6.1.1 백엔드 CI

```yaml
# .github/workflows/backend-ci.yml
name: Backend CI

on:
  push:
    paths:
      - 'backend/**'
      - '.github/workflows/backend-ci.yml'
  pull_request:
    paths:
      - 'backend/**'

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: root
          MYSQL_DATABASE: luminari_bookstore_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      
      - name: Run Tests
        working-directory: ./backend
        run: ./mvnw test
      
      - name: Build
        working-directory: ./backend
        run: ./mvnw package -DskipTests
      
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: backend-jar
          path: backend/target/*.jar
```

---

#### 6.1.2 프론트엔드 CI

```yaml
# .github/workflows/frontend-ci.yml
name: Frontend CI

on:
  push:
    paths:
      - 'frontend/**'
      - '.github/workflows/frontend-ci.yml'
  pull_request:
    paths:
      - 'frontend/**'

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      
      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci
      
      - name: Lint
        working-directory: ./frontend
        run: npm run lint
      
      - name: Type check
        working-directory: ./frontend
        run: npm run type-check
      
      - name: Build
        working-directory: ./frontend
        run: npm run build
      
      - name: Upload artifact
        uses: actions/upload-artifact@v3
        with:
          name: frontend-dist
          path: frontend/dist
```

---

#### 6.1.3 통합 배포

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches:
      - main
    tags:
      - 'v*'

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to server
        run: |
          echo "배포 스크립트 실행"
          # Docker Hub 푸시
          # 서버 SSH 접속 후 docker-compose up
```

---

### 6.2 환경별 배포

| 환경 | URL | 브랜치 | 자동 배포 |
|:-----|:----|:------|:---------|
| 로컬 | localhost:3000 | - | docker-compose |
| 개발 | dev.luminari.com | develop | GitHub Actions |
| 스테이징 | staging.luminari.com | staging | GitHub Actions |
| 프로덕션 | luminari.com | main | Manual/Tag |

---

## 7. 확장 시나리오

### 7.1 모노레포 도구 도입 시점

**현재**: 기본 모노레포 (도구 없이)
- 충분히 단순함
- 추가 도구 불필요

**확장 시점 1**: 패키지 3개 이상
- **도구**: Nx 또는 Turborepo
- **이유**: 빌드 캐싱, 병렬 실행

**확장 시점 2**: 프로젝트 10개 이상
- **도구**: Nx + 모듈 연합(Module Federation)
- **이유**: 마이크로 프론트엔드 아키텍처

---

### 7.2 멀티레포 전환 시나리오

**시나리오**: 마이크로서비스 전환 결정

**방법 1**: Git Subtree
```bash
git subtree split -P backend -b backend-repo
git push <new-backend-repo-url> backend-repo:main
```

**방법 2**: Git Filter-Branch
```bash
git filter-branch --subdirectory-filter backend -- --all
```

**결론**: 필요할 때 언제든 분리 가능하므로 지금 걱정할 필요 없음

---

### 7.3 공유 패키지 전략

**미래 구조**:
```
luminari-bookstore/
├── backend/
├── frontend/
├── packages/                   ← 공유 패키지
│   ├── types/                  ← TypeScript 타입
│   │   └── package.json
│   ├── ui-components/          ← 공유 UI 컴포넌트
│   │   └── package.json
│   └── utils/                  ← 공유 유틸리티
│       └── package.json
└── package.json                ← Workspace 루트
```

**NPM Workspaces 또는 Yarn Workspaces 사용**

---

## 8. 실행 계획

### 8.1 즉시 실행 가능한 작업

#### Step 1: 프론트엔드 프로젝트 생성
```bash
cd luminari-bookstore
npm create vite@latest frontend -- --template react-ts
cd frontend
npm install
```

#### Step 2: 필수 패키지 설치
```bash
npm install axios react-router-dom zustand
npm install -D @types/react-router-dom
```

#### Step 3: 기본 구조 생성
```bash
# 디렉토리 생성
mkdir -p src/{components,pages,services,hooks,types,utils,styles,stores}
mkdir -p src/components/{common,layout,book,member,order,community}
mkdir -p src/pages/Admin
```

#### Step 4: Vite 설정 파일 작성
- `vite.config.ts` 작성 (위 내용 참고)
- `tsconfig.json` 수정 (위 내용 참고)

#### Step 5: Docker Compose 작성
- `docker-compose.yml` 작성 (루트 디렉토리)
- 백엔드 `Dockerfile` 작성
- 프론트엔드 `Dockerfile` 작성

#### Step 6: 개발 환경 실행
```bash
# Docker Compose로 전체 환경 실행
docker-compose up -d

# 또는 개별 실행
# 백엔드
cd backend && ./mvnw spring-boot:run

# 프론트엔드
cd frontend && npm run dev
```

---

### 8.2 단계별 개발 로드맵

#### Phase 1: 프로젝트 세팅 (1주)
- [x] 모노레포 구조 결정
- [ ] 프론트엔드 프로젝트 생성
- [ ] Docker Compose 설정
- [ ] CI/CD 파이프라인 구축
- [ ] 개발 환경 문서화

#### Phase 2: 기본 기능 구현 (2주)
- [ ] 회원 인증/인가 (로그인/회원가입)
- [ ] 도서 목록/상세 조회
- [ ] 장바구니
- [ ] 주문/결제

#### Phase 3: 확장 기능 (2주)
- [ ] 리뷰 시스템
- [ ] 독서 모임
- [ ] 게이미피케이션 (레벨, 업적)
- [ ] 관리자 페이지

#### Phase 4: 최적화 및 배포 (1주)
- [ ] 성능 최적화
- [ ] SEO 최적화
- [ ] 프로덕션 배포
- [ ] 모니터링 설정

---

## 9. 참고 자료

### 9.1 모노레포 관련
- [Monorepo.tools](https://monorepo.tools/) - 모노레포 도구 비교
- [Nx](https://nx.dev/) - 모노레포 빌드 시스템
- [Turborepo](https://turbo.build/) - Vercel의 모노레포 도구

### 9.2 프론트엔드 기술 스택
- [Vite](https://vitejs.dev/) - 빌드 도구
- [React](https://react.dev/) - UI 라이브러리
- [TypeScript](https://www.typescriptlang.org/) - 타입 시스템
- [React Router](https://reactrouter.com/) - 라우팅
- [Zustand](https://zustand-demo.pmnd.rs/) - 상태 관리

### 9.3 DevOps
- [Docker](https://docs.docker.com/) - 컨테이너
- [Docker Compose](https://docs.docker.com/compose/) - 다중 컨테이너 오케스트레이션
- [GitHub Actions](https://docs.github.com/en/actions) - CI/CD

---

## 10. 결론

### 최종 결정: ✅ **모노레포 (Monorepo)**

**핵심 이유**:
1. 단일 애플리케이션에 최적
2. 소규모 팀에 적합
3. 빠른 개발 속도
4. 간단한 설정 및 관리
5. 필요 시 언제든 분리 가능

**제안 구조**:
```
luminari-bookstore/
├── backend/        ← Spring Boot
├── frontend/       ← React + Vite
├── database/       ← SQL Scripts
└── docs/           ← Documentation
```

**다음 단계**:
프론트엔드 프로젝트 생성 및 기본 구조 세팅을 시작하시겠습니까?

---

**작성 정보**:
- **문서명**: 프론트엔드 프로젝트 구조 결정: 모노레포 vs 멀티레포
- **프로젝트**: Luminari Bookstore
- **작성일**: 2025-11-19
- **버전**: 1.0
- **결정 사항**: 모노레포 채택
